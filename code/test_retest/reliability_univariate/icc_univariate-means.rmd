---
title: "Trial-level test--retest reliability analyses: univariate means, baseline session"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true

---


```{r, setup, results = FALSE}

library(colorout)
library(here)
library(reticulate)
library(tidyr)
library(dplyr)
library(purrr)
library(data.table)
library(abind)
library(mikeutils)
library(doParallel)
library(foreach)
library(future)
library(ggplot2)
library(grid)
library(gridExtra)
library(cowplot)
library(viridis)
library(psych)
library(lme4)
library(brms)

source(here("code", "_constants.R"))
source(here("code", "_atlases.R"))
source(here("code", "_funs.R"))

theme_set(theme_half_open())


## constants

subjs <- subjs_wave12
rois <- key_schaefer$parcel


## functions

icc <- function(x, nms, type, ...) {
  
  res <- ICC(x[, ..nms], ...)$results
  res[res$type == type, "ICC"]
}

pull_fixef <- function(x, nms = c("term", "b", "se", "tstat")) {
  
  res <- coef(summary(x))
  res <- cbind(rownames(res), data.table(res))
  names(res) <- nms
  
  res
  
}

pull_trcor <- function(x) attr(VarCorr(x)$subj.1, "correlation")[2, 1]


mean_crosstask_cor <- function(x) {
  
  x <- x[[1]]
  cross_wave <- x[grep("wave1", colnames(x)), grep("wave2", colnames(x))]
  
  tanh(mean(atanh(cross_wave[row(cross_wave) != col(cross_wave)])))
  
}


## read data

behav <- fread(here::here("in", "behav", "behavior-and-events_wave12_alltasks.csv"))[session == "baseline"]

fmri <- read_results(
  waves = c("wave1", "wave2"), 
  tasks = tasks, 
  sessions = "baseline", 
  subjs = subjs, 
  glmname = "null_2rpm", 
  filename = "means-trials_schaefer-parcel400_resid-errts.csv",
  fread
)
fmri <- rbindlist(fmri, idcol = "id")
fmri <- fmri[, trialnum := 1:.N, by = "id"]  ## make trial number column
fmri <- separate(fmri, id, c("wave", "task", "session", "subj"))


## bind

d <- merge(fmri, behav, by = c("task", "subj", "wave", "session", "trialnum"))


## reorder cols

trial_cols <- names(d)[!names(d) %in% rois]
cols <- c(rois, trial_cols)
d <- d[, ..cols]


## remove missing trials

print(noquote(paste0("removing ", sum(is.na(rowSums(d[, ..rois]))), " trials due to missing values")))

d <- d[!is.na(rowSums(d[, ..rois])), ]


## prep data for HLM

d$hilo <- factor(d$hilo, levels = c("lo", "hi"))
contrasts(d$hilo) <- matrix(c(-0.5, 0.5), nrow = 2, dimnames = list(c("lo", "hi"), "hi"))

d$hilo_all <- factor(d$hilo_all, levels = c("lo", "hi"))
contrasts(d$hilo_all) <- matrix(c(-0.5, 0.5), nrow = 2, dimnames = list(c("lo", "hi"), "hi"))

d_hilo <- d[!is.na(hilo)]
d_hilo_all <- d[!is.na(hilo_all)]


## make cols for random effects:

hilo <- model.matrix(~ hilo, d_hilo)[, 2]
wave <- model.matrix(~ 0 + wave, d_hilo)
#image(cbind(hilo, wave))
wave_hilo <- cbind(
	mean_wave1 = wave[, 1],
	mean_wave2 = wave[, 2],
	hilo_wave1 = hilo*wave[, 1],
	hilo_wave2 = hilo*wave[, 2]
)
image(wave_hilo)
colnames(wave_hilo) <- c("mean_wave1", "mean_wave2", "hilo_wave1", "hilo_wave2")

data_hilo <- cbind(d_hilo, wave_hilo)

```




# condition-level: 'summary statistics'


```{r icc_condition_level}


## aggregate over trials and re-format for correlation

d_sum <- d_hilo[, 
  lapply(.SD, mean), by = c("subj", "wave", "task", "hilo"), 
  .SDcols = key_schaefer$parcel
  ]  ## aggregate over trials
d_sum <-  ## 
  melt(d_sum, id.cols = c("subj", "task", "hilo"), measure.vars = key_schaefer$parcel, variable.name = "roi")
d_sum <- dcast(d_sum, subj + wave + task + roi ~ hilo, value.var = "value")  ## hilo cols
d_sum$hilo <- d_sum$hi - d_sum$lo
d_sum <- dcast(d_sum, subj + task + roi ~ wave, value.var = "hilo")  ## wave cols



## estimate

r_sum <- d_sum[,
      .(
        r = cor(wave1, wave2), 
        rho = cor(wave1, wave2, method = "spearman"),
        icc2 = icc(.SD, nms = c("wave1", "wave2"), type = "ICC2", lmer = FALSE),
        icc3 = icc(.SD, nms = c("wave1", "wave2"), type = "ICC3", lmer = FALSE)
        ),
      by = c("task", "roi")]



## plot

r_sum[, is_core32 := roi %in% rois[core32]]


## core32 vs all others:

r_sum %>%
  
  group_by(task, is_core32) %>%
  summarize(
    icc_mu = mean(icc3),
    icc_sd = sd(icc3),
  ) %>%

  ggplot(aes(task, icc_mu, fill = is_core32)) +
  
  geom_col(position = position_dodge(width = 0.5), width = 0.5, color = "black") +
  geom_errorbar(
    aes(ymax = icc_mu + icc_sd, ymin = icc_mu - icc_sd), position = position_dodge(width = 0.5), width = 0
    ) +
  scale_fill_manual(values = c(`TRUE` = "firebrick2", `FALSE` = "grey40")) +
  
  theme(legend.position = "none") +
  labs(y = "mean(ICC3)+/-sd(ICC3)", title = "baseline wave 1 vs wave 2, trial-level coefs")


## boxplots:

p_tr_sum <- r_sum %>%
  
  melt(id.cols = c("task", "roi"), measure.vars = c("r", "rho", "icc3"), variable.name = "stat") %>%
  
  ggplot(aes(stat, value)) +
  
  geom_hline(yintercept = 0, color = "grey60") +
  geom_hline(yintercept = 0.7, color = "grey60") +
  
  geom_boxplot(fill = "grey40", width = 0.25) +
  geom_point(
    data = . %>% filter(roi %in% key_schaefer$parcel[core32]), 
    position = position_jitter(width = 0.1),
    color = "firebrick2", alpha = 0.5,
    shape = 16, size = 1
    ) +
  
  facet_grid(vars(task), vars(get_network(roi))) +
  
  theme(legend.position = "none")

ggsave(
  here("out", "test_retest", "figs", "hilo-test-retest_summary-stats.pdf"), 
  p_tr_sum, 
  dev = "pdf", height = 4, width = 7
  )

p_tr_sum


## ICC vs mean activity


r_sum <- merge(
  r_sum,
  d_sum[, .(hilo_tstat = t.test(wave1 + wave2)$statistic), by = c("task", "roi")],
  by = c("roi", "task")
)


p_tr_sum_scatter <- r_sum %>%
  
  ggplot(aes(hilo_tstat, icc3)) +
  
  geom_hline(yintercept = 0, color = "grey60") +
  geom_vline(xintercept = 0, color = "grey60") +
  geom_point(aes(color = roi %in% rois[core32], alpha = roi %in% rois[core32]), shape = 16) +
  
  scale_color_manual(values = c(`TRUE` = "firebrick2", `FALSE` = "grey40")) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.2)) +
  
  facet_grid(cols = vars(task)) +
  theme(legend.position = "none")


ggsave(
  here("out", "test_retest", "figs", "hilo-test-retest_summary-stats_scatter.pdf"), 
  p_tr_sum_scatter, 
  dev = "pdf", height = 3.5, width = 7
  )

p_tr_sum_scatter

```



# trial-level: LME


Fitted with Gang Chen-style covariance structure.
6 random-effect (co)variance parameters are estimated (in grey):


```{r lme_model, echo = FALSE}

lab <- c("hi+lo, wave 1", "hi+lo, wave 2", "hi-lo, wave 1", "hi-lo, wave 2")

m <- matrix("0", ncol = 4, nrow = 4, dimnames = list(lab, lab))
diag(m) <- paste0("s_", 1:4)
m[1, 2] <- "r_1"
m[2, 1] <- "r_1"
m[3, 4] <- "r_2"
m[4, 3] <- "r_2"

m %>% 
  melt_mat %>%
  ggplot(aes(v1, v2, fill = ifelse(value == "0", "zero", "one")), color = "white") +
  geom_tile() +
  geom_text(aes(label = value)) +
  
  scale_fill_manual(values = c(zero = "white", one = "grey70")) +
  
  theme(
    legend.position = "none", 
    axis.title = element_blank(), axis.line = element_blank(), panel.border = element_rect()
    )

```

The first two rows/columns correspond to the 'intercepts', separately in wave 1 (row 1) and wave 2 (row 2).
Here, the intercepts are the average of hi and lo trialtypes.
The second two rows/columns correspond to the 'slopes' in waves 1 and 2.
Here the slope is the difference between hi and lo trialtypes.
This model assumes that intercepts and slopes are uncorrelated.
What we are interested in is $r_2$, the cross-wave (test--retest) correlation in the hilo contrast.


```{r lme_results}

## fit models

f_tr <- paste0(
  key_schaefer$parcel, 
  " ~ hilo * wave + (0 + mean_wave1 + mean_wave2 | subj) + (0 + hilo_wave1 + hilo_wave2 | subj)"
  )
names(f_tr) <- key_schaefer$parcel

m_tr <- enlist(tasks)
m_tr_fixef <- enlist(tasks)
m_tr_cors <- enlist(tasks)

for (task_val in tasks) {
  
  data_hilo_task <- data_hilo[task == task_val]
  
  m_tr[[task_val]] <- mclapply(f_tr, function(x) lmer(as.formula(x), data_hilo_task), mc.cores = n_core/2)
  
  m_tr_cors[[task_val]] <- unlist(lapply(m_tr[[task_val]], pull_trcor))
  
}

r_tr_cors <- as.data.table(do.call(cbind, m_tr_cors), keep.rownames = "roi")



## plot

r_tr_cors <- r_tr_cors %>% melt(id.vars = "roi", variable.name = "task")
r_tr_cors_filter <- r_tr_cors %>% filter(!is.nan(value))

p_tr_lme_dist <- r_tr_cors_filter %>%
  
  ggplot(aes(value)) +
  geom_histogram(fill = "grey40", bins = 20) +
  
  facet_wrap(vars(task)) +
  labs(
    x = "test-retest correlation, hilo contrast", 
    caption = paste0(nrow(r_tr_cors) - nrow(r_tr_cors_filter), " NaN obs removed")
    )

ggsave(
  here("out", "test_retest", "figs", "hilo-test-retest_lme-gang_dist.pdf"), 
  p_tr_lme_dist, 
  dev = "pdf", height = 3, width = 4
  )


p_tr_lme_dist


```



### fixed effects

This plot shows the mean t-statistics on the hi-lo contrast from an LME model fitted to each parcel.
The error bars show SD over parcels.

```{r}

## fit

f_hilo <- paste0(key_schaefer$parcel, " ~ hilo + (hilo | subj)")
names(f_hilo) <- key_schaefer$parcel

m_hilo <- enlist(tasks)
m_hilo_fixef <- enlist(tasks)

for (task_val in tasks) {

  m_hilo[[task_val]] <- mclapply(f_hilo, function(x) lmer(as.formula(x), d_hilo[task == task_val]), mc.cores = n_core/2)

  m_hilo_fixef[[task_val]] <- rbindlist(lapply(m_hilo[[task_val]], pull_fixef), idcol = "roi")

}

r_hilo_fixef <- rbindlist(m_hilo_fixef, idcol = "task")



## plot

r_hilo_fixef[, is_core32 := roi %in% rois[core32]]


r_hilo_fixef %>%
  
  filter(term == "hilohi") %>%
  
  ggplot(aes(task, tstat, fill = is_core32)) +
  
  stat_summary(geom = "col", fun = mean, position = position_dodge(width = 0.5), width = 0.5, color = "black") +
  stat_summary(
    geom = "errorbar", 
    fun.data = function(tstat) data.frame(ymax = mean(tstat) + sd(tstat), ymin = mean(tstat) - sd(tstat)),
    position = position_dodge(width = 0.5), width = 0
    ) +
  
  scale_fill_manual(values = c(`TRUE` = "firebrick2", `FALSE` = "grey40")) +
  
  theme(legend.position = "none") +
  labs(y = "mean(tstat)+/-sd(tstat)", title = "baseline wave 1 + wave 2, trial-level tstats")


```



# trial-level: hierarcical bayesian models

Similar structure as LME above.
As in Chen et al. (2021), assume response is distributed as Student's t (providing robustness against outliers).
Same priors used here as in Chen et al. (2021), which are the default priors in brms for this model structure.


```{r}

fnames_results_hbm <- here("out", "test_retest", paste0("fits_hba_chenstyle_", tasks, ".RDS"))
should_fit_models <- any(!file.exists(fnames_results_hbm))

```

## fit models

```{r, eval = should_fit_models}

# task_i <- 1
# roi_i <- 1


## prep data

data_hilo_l <- 
  melt(
    data_hilo, 
    id.vars = c(trial_cols, "mean_wave1", "mean_wave2", "hilo_wave1", "hilo_wave2"), 
    variable.name = "roi", value.name = "bold"
  )

model_cols <- c("subj", "task", "wave", "roi", "hilo", "mean_wave1", "mean_wave2", "hilo_wave1", "hilo_wave2", "bold")
data_hilo_l <- data_hilo_l[, ..model_cols]


## model info

f <- formula(
  bold ~ hilo * wave + 
    (0 + mean_wave1 + mean_wave2 | subj) + 
    (0 + hilo_wave1 + hilo_wave2 | subj)
  )
prior_student <- get_prior(formula = f, data = d_hilo_l, family = student)


## run
run_time <- enlist(tasks)
for (task_i in seq_along(tasks)) {

    ## subset and format
    
    task_val <- tasks[task_i]
    dii <- d_hilo_l[task == task_val]
    
    l <- split(dii, dii$roi)
    
    
    ## fit
    
    start_time <- Sys.time()
    plan(multicore, workers = 28)
    
    fits <- brm_multiple(
      formula = f,
      data = l,
      family = student,
      warmup = 1000, iter = 2000, chains = 4,
      control = list(adapt_delta = 0.95),
      combine = FALSE,
      seed = 0
      )
    
    plan(sequential)
    run_time[[task_i]] <- Sys.time() - start_time
    
    ## save
    
    fname_results <- here("out", "test_retest", paste0("fits_hba_chenstyle_", task_val, ".RDS"))
    saveRDS(fits, fname_results)
    
    print(run_time)

}

```

## read results

```{r, cache = TRUE, cache.lazy = FALSE}

## get reliability estimates (all ROIs):

fits <- enlist(tasks)
posterior_trr <- enlist(tasks)

for (task_i in seq_along(tasks)) {
  
  task_val <- tasks[task_i]
  fname_results_val <- fnames_results_hbm[task_i]
  
  fits[[task_val]] <- readRDS(fname_results_val)
  names(fits[[task_val]]) <- rois
    
  ## extract correlation info:
  
  posterior_trr_task <- 
	  lapply(
	    fits[[task_val]], 
	    function(x) {
	      x <- as_draws_matrix(x, variable = "cor_subj__hilo_wave1__hilo_wave2")
	      x <- data.table(x)
	      x
	      }
	    )
  
  posterior_trr[[task_val]] <- rbindlist(posterior_trr_task, idcol = "roi")
  
  print(task_val)
  
}

posterior_trr_d <- rbindlist(posterior_trr, idcol = "task")


```





## plot

```{r width = 11, height = 11}


## density core 32

p_posteriors <- posterior_trr_d[roi %in% rois[core32]] %>%
  
  ggplot(aes(cor_subj__hilo_wave1__hilo_wave2, fill = task, color = task)) +
  geom_density(alpha = 1/3, size = 1) +
  facet_wrap(vars(roi)) +
  
  scale_color_brewer(type = "qual", palette = 7) +
  scale_fill_brewer(type = "qual", palette = 7) +
  
  theme(legend.position = c(0.5, 0.05)) +
  labs(x = "cor(hilo_wave1, hilo_wave2)", y = "posterior density", title = "test-retest correlations in core 32")

p_posteriors

ggsave(here("out", "test_retest", "figs", "posterior_trr_core32.pdf"), p_posteriors, width = 10, height = 10)




## scatter plots

get_map <- function(x) {
  
  dens <- density(x)
  dens$x[which.max(dens$y)]
  
}


r_tr <- posterior_trr_d[, 
                .(
                  mean_hbm = mean(cor_subj__hilo_wave1__hilo_wave2),
                  map_hbm = get_map(cor_subj__hilo_wave1__hilo_wave2)
                  ), 
                by = c("task", "roi")
                ] %>%
  full_join(r_sum, by = c("task", "roi"))


p_scatter_means <- r_tr %>%

	ggplot(aes(mean_hbm, r)) +
	geom_abline(color = "grey60") +
	geom_hline(yintercept = 0, color = "grey60") +
	geom_vline(xintercept = 0, color = "grey60") +
	geom_point(aes(color = is_core32, alpha = is_core32), shape = 16) +
  
  scale_color_manual(values = c(`TRUE` = "firebrick2", `FALSE` = "black")) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.5)) +
  
  theme(legend.position = "none") +
	facet_wrap(vars(task)) +
  labs(x = "HBM posterior mean", y = "summary stat", y = "test retest correlations")

p_scatter_means

ggsave(here("out", "test_retest", "figs", "posterior_scatter.pdf"), p_scatter_means, width = 6, height = 6)


p_scatter_map <- r_tr %>%

	ggplot(aes(map_hbm, r)) +
	geom_abline(color = "grey60") +
	geom_hline(yintercept = 0, color = "grey60") +
	geom_vline(xintercept = 0, color = "grey60") +
	geom_point(aes(color = is_core32, alpha = is_core32), shape = 16) +
  
  scale_color_manual(values = c(`TRUE` = "firebrick2", `FALSE` = "black")) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.5)) +
  
  theme(legend.position = "none") +
	facet_wrap(vars(task)) +
  labs(x = "HBM MAP", y = "summary stat", y = "test retest correlations")

p_scatter_map

ggsave(here("out", "test_retest", "figs", "posterior_scatter_map.pdf"), p_scatter_map, width = 6, height = 6)


```


## variance ratios

```{r width = 11, height = 11}

ratios <- enlist(tasks)
for (task_val in tasks) {

	ratio_task  <- lapply(

		fits[[task_val]],

			function(x) {

			varcor <- VarCorr(x)
			resid_sd <- varcor$residual$sd[1]
			subj_mean_sd <- sqrt(mean(varcor$subj$sd[c("mean_wave1", "mean_wave2"), "Estimate"]^2))
			subj_hilo_sd <- sqrt(mean(varcor$subj$sd[c("hilo_wave1", "hilo_wave2"), "Estimate"]^2))

			ratio_mean <- (resid_sd / subj_mean_sd)^2
			ratio_hilo <- (resid_sd / subj_hilo_sd)^2

			data.table(
			  resid_sd = resid_sd, subj_mean_sd = subj_mean_sd, subj_hilo_sd = subj_hilo_sd,
			  ratio_mean = ratio_mean,
			  ratio_hilo = ratio_hilo
			  )

		}
	)

	ratios[[task_val]] <- rbindlist(ratio_task, idcol = "roi")

}
ratios <- rbindlist(ratios, idcol = "task")


p_vardecomp <- ratios %>%
	
  melt(id.vars = c("task", "roi")) %>%
  filter(variable %in% c("resid_sd", "subj_mean_sd", "subj_hilo_sd")) %>%
  
	ggplot(aes(variable, value)) +
	geom_boxplot(width = 0.2, fill = "grey40") +
  
	facet_grid(rows = vars(task)) +
  coord_flip() +
  labs(x = "parameter", y = "posterior mean", title = "variance decomposition")

p_vardecomp

ggsave(here("out", "test_retest", "figs", "variance_ratio.pdf"), p_vardecomp, width = 6, height = 4.5)


p_ratio <- ratios %>%
	
  melt(id.vars = c("task", "roi")) %>%
  filter(variable %in% c("ratio_mean", "ratio_hilo")) %>%
  
	ggplot(aes(variable, value)) +
	geom_boxplot(width = 0.2, fill = "grey40") +
  
	facet_grid(rows = vars(task)) +
  labs(x = "parameter", y = "posterior mean (log scale)", title = "variance ratio: trial-level/subject-level") +
  scale_y_log10() +
  
  coord_flip()
  
p_ratio
  
ggsave(here("out", "test_retest", "figs", "variance_ratio.pdf"), p_ratio, width = 6, height = 4.5)



```




# summary

## brains