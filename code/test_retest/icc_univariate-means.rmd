---
title: "Trial-level ICC analyses: univariate means, baseline session"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true

---


```{r, setup, results = FALSE}

library(colorout)
library(here)
library(reticulate)
library(tidyr)
library(dplyr)
library(purrr)
library(data.table)
library(abind)
library(mikeutils)
library(doParallel)
library(foreach)
library(future)
library(ggplot2)
library(grid)
library(gridExtra)
library(cowplot)
library(viridis)
library(psych)
library(lme4)
library(brms)

source(here("code", "_constants.R"))
source(here("code", "_atlases.R"))
source(here("code", "_funs.R"))

theme_set(theme_half_open())


## constants

subjs <- subjs_wave12
rois <- key_schaefer$parcel


## functions

icc <- function(x, nms, type, ...) {
  
  res <- ICC(x[, ..nms], ...)$results
  res[res$type == type, "ICC"]
}

pull_fixef <- function(x, nms = c("term", "b", "se", "tstat")) {
  
  res <- coef(summary(x))
  res <- cbind(rownames(res), data.table(res))
  names(res) <- nms
  
  res
  
}

pull_trcor <- function(x) attr(VarCorr(x)$subj.1, "correlation")[2, 1]


mean_crosstask_cor <- function(x) {
  
  x <- x[[1]]
  cross_wave <- x[grep("wave1", colnames(x)), grep("wave2", colnames(x))]
  
  tanh(mean(atanh(cross_wave[row(cross_wave) != col(cross_wave)])))
  
}


## read data

behav <- fread(here::here("in", "behav", "behavior-and-events_wave12_alltasks.csv"))[session == "baseline"]

fmri <- read_results(
  waves = c("wave1", "wave2"), 
  tasks = tasks, 
  sessions = "baseline", 
  subjs = subjs, 
  glmname = "null_2rpm", 
  filename = "means-trials_schaefer-parcel400_resid-errts.csv",
  fread
)
fmri <- rbindlist(fmri, idcol = "id")
fmri <- fmri[, trialnum := 1:.N, by = "id"]  ## make trial number column
fmri <- separate(fmri, id, c("wave", "task", "session", "subj"))


## bind

d <- merge(fmri, behav, by = c("task", "subj", "wave", "session", "trialnum"))


## reorder cols

trial_cols <- names(d)[!names(d) %in% rois]
cols <- c(rois, trial_cols)
d <- d[, ..cols]


## remove missing trials

print(noquote(paste0("removing ", sum(is.na(rowSums(d[, ..rois]))), " trials due to missing values")))

d <- d[!is.na(rowSums(d[, ..rois])), ]


## prep data for HLM

d$hilo <- factor(d$hilo, levels = c("lo", "hi"))
contrasts(d$hilo) <- matrix(c(-0.5, 0.5), nrow = 2, dimnames = list(c("lo", "hi"), "hi"))

d$hilo_all <- factor(d$hilo_all, levels = c("lo", "hi"))
contrasts(d$hilo_all) <- matrix(c(-0.5, 0.5), nrow = 2, dimnames = list(c("lo", "hi"), "hi"))

d_hilo <- d[!is.na(hilo)]
d_hilo_all <- d[!is.na(hilo_all)]


```




# condition-level: 'summary statistics'


## per task

```{r icc_condition_level}


## aggregate over trials and re-format for correlation

d_sum <- d_hilo[, 
  lapply(.SD, mean), by = c("subj", "wave", "task", "hilo"), 
  .SDcols = key_schaefer$parcel
  ]  ## aggregate over trials
d_sum <-  ## 
  melt(d_sum, id.cols = c("subj", "task", "hilo"), measure.vars = key_schaefer$parcel, variable.name = "roi")
d_sum <- dcast(d_sum, subj + wave + task + roi ~ hilo, value.var = "value")  ## hilo cols
d_sum$hilo <- d_sum$hi - d_sum$lo
d_sum <- dcast(d_sum, subj + task + roi ~ wave, value.var = "hilo")  ## wave cols



## estimate

r_sum <- d_sum[,
      .(
        r = cor(wave1, wave2), 
        rho = cor(wave1, wave2, method = "spearman"),
        icc2 = icc(.SD, nms = c("wave1", "wave2"), type = "ICC2", lmer = FALSE),
        icc3 = icc(.SD, nms = c("wave1", "wave2"), type = "ICC3", lmer = FALSE)
        ),
      by = c("task", "roi")]



## plot

r_sum[, is_core32 := roi %in% rois[core32]]


## core32 vs all others:

r_sum %>%
  
  group_by(task, is_core32) %>%
  summarize(
    icc_mu = mean(icc3),
    icc_sd = sd(icc3),
  ) %>%

  ggplot(aes(task, icc_mu, fill = is_core32)) +
  
  geom_col(position = position_dodge(width = 0.5), width = 0.5, color = "black") +
  geom_errorbar(aes(ymax = icc_mu + icc_sd, ymin = icc_mu - icc_sd), position = position_dodge(width = 0.5), width = 0) +
  scale_fill_manual(values = c(`TRUE` = "firebrick2", `FALSE` = "grey40")) +
  
  theme(legend.position = "none") +
  labs(y = "mean(ICC3)+/-sd(ICC3)", title = "baseline wave 1 vs wave 2, trial-level coefs")


## boxplots:

p_tr_sum <- r_sum %>%
  
  melt(id.cols = c("task", "roi"), measure.vars = c("r", "rho", "icc3"), variable.name = "stat") %>%
  
  ggplot(aes(stat, value)) +
  
  geom_hline(yintercept = 0, color = "grey60") +
  geom_hline(yintercept = 0.7, color = "grey60") +
  
  geom_boxplot(fill = "grey40", width = 0.25) +
  geom_point(
    data = . %>% filter(roi %in% key_schaefer$parcel[core32]), 
    position = position_jitter(width = 0.1),
    color = "firebrick2", alpha = 0.5,
    shape = 16, size = 1
    ) +
  
  facet_grid(vars(task), vars(get_network(roi))) +
  
  theme(legend.position = "none")

ggsave(
  here("out", "icc", "figs", "hilo-test-retest_summary-stats.pdf"), 
  p_tr_sum, 
  dev = "pdf", height = 4, width = 7
  )

p_tr_sum


## ICC vs mean activity


r_sum <- merge(
  r_sum,
  d_sum[, .(hilo_tstat = t.test(wave1 + wave2)$statistic), by = c("task", "roi")],
  by = c("roi", "task")
)


p_tr_sum_scatter <- r_sum %>%
  
  ggplot(aes(hilo_tstat, icc3)) +
  
  geom_hline(yintercept = 0, color = "grey60") +
  geom_vline(xintercept = 0, color = "grey60") +
  geom_point(aes(color = roi %in% rois[core32], alpha = roi %in% rois[core32]), shape = 16) +
  
  scale_color_manual(values = c(`TRUE` = "firebrick2", `FALSE` = "grey40")) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.2)) +
  
  facet_grid(cols = vars(task)) +
  theme(legend.position = "none")


ggsave(
  here("out", "icc", "figs", "hilo-test-retest_summary-stats_scatter.pdf"), 
  p_tr_sum_scatter, 
  dev = "pdf", height = 3.5, width = 7
  )

p_tr_sum_scatter

```


## all tasks


```{r icc_condition_level_alltask}


## estimate

d_sum_alltask <- dcast(d_sum, subj + roi ~ task, value.var = c("wave1", "wave2"))
r_sum_alltask <- d_sum_alltask[, .(r = list(cor(.SD))), by = "roi", .SDcols = c(combo_paste(c("wave1", "wave2"), tasks))]

r_sum_crosstask <- r_sum_alltask[, .(r_crosstask = mean_crosstask_cor(r)), by = "roi"]



## plot

r_sum_crosstask[, is_core32 := roi %in% rois[core32]]


## core32 vs all others:

r_sum_crosstask %>%
  
  group_by(is_core32) %>%
  summarize(
    r_mu = mean(r_crosstask),
    r_sd = sd(r_crosstask),
  ) %>%

  ggplot(aes(is_core32, r_mu, fill = is_core32)) +
  
  geom_col(position = position_dodge(width = 0.5), width = 0.5, color = "black") +
  geom_errorbar(aes(ymax = r_mu + r_sd, ymin = r_mu - r_sd), position = position_dodge(width = 0.5), width = 0) +
  scale_fill_manual(values = c(`TRUE` = "firebrick2", `FALSE` = "grey40")) +
  
  theme(legend.position = "none") +
  labs(y = "mean(r)+/-sd(r)", title = "mean cross-task test-retest correlation\nbaseline wave 1 vs wave 2, trial-level coefs")



## boxplots:

p_tr_sum_crosstask <-
  
  r_sum_crosstask %>%
  
  ggplot(aes(get_network(roi), r_crosstask)) +
  
  geom_hline(yintercept = 0, color = "grey60") +
  # geom_hline(yintercept = 0.7, color = "grey60") +
  
  geom_boxplot(fill = "grey40", width = 0.25) +
  geom_point(
    data = . %>% filter(roi %in% key_schaefer$parcel[core32]), 
    position = position_jitter(width = 0.1),
    color = "firebrick2", alpha = 0.5,
    shape = 16, size = 1
    ) +
    
    labs(y = "mean(r)", title = "mean cross-task test-retest correlation\nbaseline wave 1 vs wave 2, trial-level coefs")


ggsave(
  here("out", "icc", "figs", "hilo-test-retest_summary-stats_crosstask.pdf"), 
  p_tr_sum_crosstask, 
  dev = "pdf", height = 4, width = 7
  )

p_tr_sum_crosstask


```





## comparison to glm-based coefficients

## impact of hilo_all on core32



# trial-level: LME


## per task

Fitted with Gang Chen-style covariance structure.
6 random-effect (co)variance parameters are estimated (in grey):


```{r lme_model, echo = FALSE}

lab <- c("hi+lo, wave 1", "hi+lo, wave 2", "hi-lo, wave 1", "hi-lo, wave 2")

m <- matrix("0", ncol = 4, nrow = 4, dimnames = list(lab, lab))
diag(m) <- paste0("s_", 1:4)
m[1, 2] <- "r_1"
m[2, 1] <- "r_1"
m[3, 4] <- "r_2"
m[4, 3] <- "r_2"

m %>% 
  melt_mat %>%
  ggplot(aes(v1, v2, fill = ifelse(value == "0", "zero", "one")), color = "white") +
  geom_tile() +
  geom_text(aes(label = value)) +
  
  scale_fill_manual(values = c(zero = "white", one = "grey70")) +
  
  theme(
    legend.position = "none", 
    axis.title = element_blank(), axis.line = element_blank(), panel.border = element_rect()
    )

```

The first two rows/columns correspond to the 'intercepts', separately in wave 1 (row 1) and wave 2 (row 2).
Here, the intercepts are the average of hi and lo trialtypes.
The second two rows/columns correspond to the 'slopes' in waves 1 and 2.
Here the slope is the difference between hi and lo trialtypes.
This model assumes that intercepts and slopes are uncorrelated.
What we are interested in is $r_2$, the cross-wave (test--retest) correlation in the hilo contrast.

```{r lme_results}


## build gang-style random effect design matrix

wave_hilo <- model.matrix(~ hilo * wave, d_hilo)
colnames(wave_hilo) <- c("mean_wave1", "hilo_wave1", "mean_wave2", "hilo_wave2")
gmean <- wave_hilo[, c('mean_wave1', 'mean_wave2')]
hiloef <- wave_hilo[, c('hilo_wave1', 'hilo_wave2')]


## fit models

f_tr <- paste0(key_schaefer$parcel, " ~ hilo * wave + (0 + gmean_task | subj) + (0 + hiloef_task | subj)")
names(f_tr) <- key_schaefer$parcel

m_tr <- enlist(tasks)
m_tr_fixef <- enlist(tasks)
m_tr_cors <- enlist(tasks)

for (task_val in tasks) {
  
  ## subset
  
  gmean_task <- gmean[d_hilo$task == task_val, ]
  hiloef_task <- gmean[d_hilo$task == task_val, ]
  d_hilo_task <- d_hilo[task == task_val]
  
  ## fit
  
  m_tr[[task_val]] <- mclapply(f_tr, function(x) lmer(as.formula(x), d_hilo_task), mc.cores = n_core/2)
  
  ## extract
  
  m_tr_cors[[task_val]] <- unlist(lapply(m_tr[[task_val]], pull_trcor))
  
}

r_tr_cors <- as.data.table(do.call(cbind, m_tr_cors), keep.rownames = "roi")


## plot


r_tr_cors <- r_tr_cors %>% melt(id.vars = "roi", variable.name = "task")
r_tr_cors_filter <- r_tr_cors %>% filter(!is.nan(value))

p_tr_lme_dist <- r_tr_cors_filter %>%
  
  ggplot(aes(value)) +
  geom_histogram(fill = "grey40", bins = 20) +
  
  facet_wrap(vars(task)) +
  labs(
    x = "test-retest correlation, hilo contrast", 
    caption = paste0(nrow(r_tr_cors) - nrow(r_tr_cors_filter), " NaN obs removed")
    )

ggsave(
  here("out", "icc", "figs", "hilo-test-retest_lme-gang_dist.pdf"), 
  p_tr_lme_dist, 
  dev = "pdf", height = 3, width = 4
  )


p_tr_lme_dist


```

### fixed effects

This plot shows the mean t-statistics on the hi-lo contrast from an LME model fitted to each parcel.
The error bars show SD over parcels.

```{r}

## fit

f_hilo <- paste0(key_schaefer$parcel, " ~ hilo + (hilo | subj)")
names(f_hilo) <- key_schaefer$parcel

m_hilo <- enlist(tasks)
m_hilo_fixef <- enlist(tasks)

for (task_val in tasks) {

  m_hilo[[task_val]] <- mclapply(f_hilo, function(x) lmer(as.formula(x), d_hilo[task == task_val]), mc.cores = n_core/2)

  m_hilo_fixef[[task_val]] <- rbindlist(lapply(m_hilo[[task_val]], pull_fixef), idcol = "roi")

}

r_hilo_fixef <- rbindlist(m_hilo_fixef, idcol = "task")



## plot

r_hilo_fixef[, is_core32 := roi %in% rois[core32]]


r_hilo_fixef %>%
  
  filter(term == "hilohi") %>%
  
  ggplot(aes(task, tstat, fill = is_core32)) +
  
  stat_summary(geom = "col", fun = mean, position = position_dodge(width = 0.5), width = 0.5, color = "black") +
  stat_summary(
    geom = "errorbar", 
    fun.data = function(tstat) data.frame(ymax = mean(tstat) + sd(tstat), ymin = mean(tstat) - sd(tstat)),
    position = position_dodge(width = 0.5), width = 0
    ) +
  
  scale_fill_manual(values = c(`TRUE` = "firebrick2", `FALSE` = "grey40")) +
  
  theme(legend.position = "none") +
  labs(y = "mean(tstat)+/-sd(tstat)", title = "baseline wave 1 + wave 2, trial-level tstats")


```



## all tasks





# trial-level: HBA

Similar structure as LME above.
As in Chen et al. (2021), assume response is distributed as Student's t (providing robustness against outliers).
Same priors used here as in Chen et al. (2021), which are the default priors in brms for this model structure.


```{r}
# task_i <- 1
# roi_i <- 1



## prep data

d_hilo_l <- melt(d_hilo, id.vars = trial_cols, variable.name = "roi", value.name = "bold")

wave_hilo <- model.matrix(~ hilo * wave, d_hilo_l)
colnames(wave_hilo) <- c("mean_wave1", "hilo_wave1", "mean_wave2", "hilo_wave2")
d_hilo_l <- cbind(d_hilo_l, wave_hilo)

model_cols <- c("subj", "task", "wave", "roi", "hilo", "mean_wave1", "mean_wave2", "hilo_wave1", "hilo_wave2", "bold")
d_hilo_l <- d_hilo_l[, ..model_cols]


## model info

f <- formula(
  bold ~ hilo * wave + 
    (0 + mean_wave1 + mean_wave2 | subj) + 
    (0 + hilo_wave1 + hilo_wave2 | subj)
  )
prior_student <- get_prior(formula = f, data = d_hilo_l, family = student)


## run

for (task_i in seq_along(tasks)) {

    ## subset and format
    
    task_val <- tasks[task_i]
    dii <- d_hilo_l[task == task_val]
    
    l <- split(dii, dii$roi)
    
    
    ## fit
    
    start_time <- Sys.time()
    plan(multicore, workers = 28)
    
    fits <- brm_multiple(
      formula = f,
      data = l,
      family = student,
      warmup = 1000, iter = 2000, chains = 4,
      control = list(adapt_delta = 0.95),
      combine = FALSE,
      seed = 0
      )
    
    plan(sequential)
    run_time <- Sys.time() - start_time
    
    ## save
    
    fname_results <- here("out", "test_retest", paste0("fits_hba_chenstyle_", task_val, ".RDS"))
    saveRDS(fits, fname_results)
    
    print(run_time)

}






allfits_core32 <- enlist(tasks)
for (task_val in tasks) {
  
  fname_results <- here("out", "test_retest", paste0("fits_hba_chenstyle_", task_val, ".RDS"))
  allfits_core32[[task_val]] <- readRDS(fname_results)[core32]
  
}

r_tr_hbm <- enlist(tasks)
for (task_val in tasks) {
  
  r_tr_hbm[[task_val]] <- 
    vapply(
      allfits_core32[[task_val]], 
      function(x) mean(as_draws_df(x)$cor_subj__hilo_wave1__hilo_wave2), as.numeric(1)
    )
  
}
r_tr_hbm <- bind_rows(r_tr_hbm)
r_tr_hbm$roi <- rois[core32]






# cl <- makeCluster(2)  ## with cores = 4, leaves 32-24 free
# registerDoParallel(cl)
# res <- 
#   
#   foreach(
#     roi_i = seq_along(rois)[1:2], 
#     .inorder = FALSE, 
#     .packages = c("brms", "data.table")
#     ) %dopar% {
#       
#       
#       ## subset roi col:
#         
#       roi_val <- rois[roi_i]
#       cols_model <- c(roi_val, "hilo", "subj", "wave")
#       d_task_sub <- d_task[, ..cols_model]
#       
#       
#       ## make cols for random effect specification:
#       
#       wave_hilo <- model.matrix(~ hilo*wave, d_task_sub)
#       colnames(wave_hilo) <- c("mean_wave1", "hilo_wave1", "mean_wave2", "hilo_wave2")
#       dii <- cbind(d_task_sub, wave_hilo)
#       
#       ## get formula:
#       
#       f <-
#         as.formula(
#           paste0(
#             roi_val,
#             " ~ hilo * wave + (0 + mean_wave1 + mean_wave2 | subj) + (0 + hilo_wave1 + hilo_wave2 | subj)"
#             )
#         )
#       
#       ## fit model:
# 
#       
#       # fit <- brm(
#       #   formula = f,
#       #   data = dii,
#       #   family = student,
#       #   warmup = 1000, iter = 2000, chains = 4,
#       #   control = list(adapt_delta = 0.99),
#       #   cores = 4
#       #   )
#   (run_time <- Sys.time() - start_time)
# 
#       fit$model_name <- roi_val
# 
#       fit
#         
# }
# stopCluster(cl)


```






# summary

## brains